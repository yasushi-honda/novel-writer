# 小説らいたー システム仕様書

## 00. 概要

**要約:** この章では、アプリケーション「小説らいたー」の全体像、目的、主な特徴、そして基本的なシステム構造について概説します。

### アプリ名と目的
- **アプリ名:** 小説らいたー (Ver7)
- **目的:** AIアシスタントとの対話的な共同作業を通じて、ユーザーの小説制作体験を加速・深化させるための統合執筆支援アプリケーションです。アイデアの創出から設定管理、執筆、推敲、書き出しまで、創作活動の全工程をサポートします。

### 主な特徴
- **デュアルAIモード:** アイデア出しや相談を行う「相談モード」と、物語の続きを生成する「執筆モード」をシームレスに切り替え可能。
- **詳細な設定管理:** キャラクター、世界観、ナレッジ（作中ルール）などを構造化して管理し、物語の一貫性を維持。
- **視覚的プロットツール:** 相関図、タイムライン、プロットボードといった視覚的なツールで、複雑な物語構造を直感的に整理。
- **コンテキスト参照:** AIはプロジェクト内の設定、ナレッジ、過去の本文、プロット要約をコンテキストとして参照し、文脈に沿った応答を生成。
- **柔軟なカスタマイズ:** ユーザーの文体模倣、AIの性格（ペルソナ）設定、出力フォーマットなど、AIの挙動を細かく調整可能。

### 想定ユーザー層
- AIの支援を受けながら、物語のアイデアを形にしたい初心者作家。
- 複雑な設定やプロットを効率的に管理したい中〜上級者作家。
- 創作の壁打ち相手やインスピレーション源としてAIを活用したいすべてのクリエイター。

### 全体の構造図（概念）
```
[ User Interface (React Components) ]
      ↑↓ (User Actions / UI Updates)
[ State Management (Zustand Store) ]
      ↑↓ (State Changes / Data Flow)
[  Business Logic & AI Interface  ]
      ↑↓ (API Calls / Data Formatting)
[  External Services (Gemini API) ]
      ↑↓ (Data Persistence)
[   Local Storage (Browser)      ]
```
- **UI層:** `components`ディレクトリ内のReactコンポーネント群。ユーザーとの対話を受け持つ。
- **State層:** `store`ディレクトリ内のZustandストア。アプリケーション全体の状態を一元管理。
- **Logic層:** `api`ディレクトリ群と`utils.ts`。UIからの要求を解釈し、APIへのリクエスト整形やデータ処理を行う。
- **Service層:** Google Gemini API。言語生成、画像生成などの核となる機能を提供。
- **Persistence層:** ブラウザの`localStorage`。Zustandの`persist`ミドルウェアを介して、プロジェクトデータを永続化。

#### 開発者向け備考
- 現状のアーキテクチャはクライアントサイドに完結しており、セットアップが容易な反面、大規模なデータや共同編集には不向きです。将来的な拡張を視野に入れる場合、バックエンドサーバーとデータベースの導入を検討する必要があります。

#### 整合性スコア（自己評価）: 95/100
- 概要として、アプリケーションの核心的なコンセプトと構造を網羅的に説明できているため。

---

## 01. システム全体構成

**要約:** この章では、アプリケーションを構成する主要なモジュール、データ構造、保存形式、そしてデータのインポート／エクスポート処理について技術的に詳述します。

### 各モジュールの役割
- **`App.tsx`:** アプリケーションのルートコンポーネント。主要な画面レイアウト（パネル構成）と、モーダルウィンドウの管理を一括して行う`ModalManager`を配置します。
- **`store/*.ts`:** アプリケーションの状態管理を担当するZustandストア群。機能ごとにスライス（`projectSlice`, `uiSlice`など）に分割されており、関心事を分離しています。`store/index.ts`でこれらを結合し、`persist`ミドルウェアを適用して`localStorage`への永続化を実現しています。
- **`components/*.ts`:** 各UIパーツの実装。パネル、モーダル、ボタンなど、再利用可能なコンポーネントで構成されています。
- **`apiUtils.ts`, `*Api.ts`:** Google Gemini APIとの通信ロジックをカプセル化したモジュール群。システムプロンプトの構築、APIリクエスト、エラーハンドリング、タイムアウト処理などを担当します。
- **`types.ts`:** TypeScriptの型定義を集約。`Project`型を筆頭に、アプリケーション全体で利用されるデータ構造を定義しています。
- **`utils.ts`:** 汎用的なヘルパー関数群。Markdownのパース処理（`parseMarkdown`）、プロジェクトデータの検証・サニタイズ（`validateAndSanitizeProjectData`）などが含まれます。

### データ構造と保存形式
- **目的:** アプリケーションの状態、特にユーザーが作成したプロジェクトデータを永続化します。
- **使用方法:** ユーザーは意識することなく、編集内容は自動的にブラウザの`localStorage`に保存されます。
- **AIとの関係:** AIが参照するコンテキストのほぼすべてが、このデータ構造に含まれています。
- **内部処理:**
  - アプリケーションの状態は、`store/index.ts`の`useStore`によって単一のオブジェクトとして管理されます。
  - `persist`ミドルウェアの設定により、`allProjectsData`（全プロジェクトデータ）と`activeProjectId`（現在開いているプロジェクトのID）などが`localStorage`の`NOVEL_WRITER_storage`というキーにJSON形式で保存されます。
  - アプリケーション起動時、このキーからデータが読み込まれ、ストアの初期状態として復元されます。
- **注意点:**
  - データはクライアントのブラウザ内にのみ保存されるため、ブラウザのキャッシュクリアや別PCでの作業には対応していません。
  - データサイズが大きくなると、`localStorage`の容量上限（通常5〜10MB）に達する可能性があります。

### ファイル間の依存関係
- `App.tsx`は`components`, `store`, `hooks`に依存します。
- `components`は`store`（状態の読み取りとアクションの実行）、`icons`、`types`に依存します。
- `store`のスライスは、相互に`get()`を介して他のスライスの状態を参照・利用することがあります。また、`aiSlice`は`api`モジュール群に強く依存します。
- `api`モジュール群は`apiUtils.ts`と`types.ts`に依存します。

### バックアップ・エクスポート処理
- **目的:** ユーザーがプロジェクトデータをファイルとして保存し、バックアップや他環境への移行を可能にします。
- **使用方法:**
  - **エクスポート:** 左パネルの「保存 & 書き出し」メニューから「プロジェクト(.json)」を選択。
  - **インポート:** プロジェクト選択画面の「プロジェクトをインポート」ボタンから`.json`ファイルを選択。
- **内部処理:**
  - **エクスポート (`handleExportProject`):** 現在のプロジェクトの`Project`オブジェクトを`JSON.stringify`で文字列化し、Blobを作成してダウンロードリンクを生成します。
  - **インポート (`importProject`):** 選択された`.json`ファイルを読み込み、`JSON.parse`でオブジェクト化。`validateAndSanitizeProjectData`関数でデータの検証と不足プロパティの補完を行った後、`allProjectsData`ストアに追加してアクティブなプロジェクトとして開きます。
- **注意点:** インポート時にIDが重複するプロジェクトが存在する場合、既存のものが上書きされます。

#### 開発者向け備考
- `validateAndSanitizeProjectData`は、過去バージョンで作成されたプロジェクトファイルをインポートする際の互換性維持に極めて重要です。新しいプロパティを追加した際は、この関数にデフォルト値の設定を追加する必要があります。
- 現在のUndo/Redo機能（`historySlice`）は、操作ごとに`Project`オブジェクト全体を配列に保存する方式であり、メモリ消費が大きくなる可能性があります。将来的には、差分（パッチ）を記録する方式への変更を検討すべきです。

#### 整合性スコア（自己評価）: 90/100
- システムの基本的な骨格とデータフローを正確に記述できていますが、より詳細なシーケンス図などがあればさらに理解が深まるため。

---

## 02. 画面構成とUIフロー

**要約:** この章では、アプリケーションの主要な画面構成と、ユーザーが目標を達成するための典型的な操作フロー（導線）について解説します。

### 画面の全体マップ
アプリケーションは主に2つの画面で構成されます。

1.  **プロジェクト選択画面 (`ProjectSelectionScreen.tsx`)**
    - 新規プロジェクトの作成（シンプル/標準モード選択）
    - 既存プロジェクトの一覧表示と選択
    - プロジェクトのインポート/削除

2.  **メイン画面 (`App.tsx`)**
    - **ヘッダー (`Header.tsx`):** プロジェクト名、表示設定、プレビュー、書き出し、検索などのグローバルな操作。
    - **左パネル (`LeftPanel.tsx`):** プロジェクトの設定資産を管理するエリア。タブで表示を切り替え。
      - `設定ライブラリ`タブ: キャラクター、世界観、ナレッジ、プロットなどの設定項目へのアクセス。
      - `アウトライン`タブ: 本文の見出し（章タイトル）を一覧表示し、ナビゲーションと並べ替えを提供。
      - `バージョン管理`タブ: スナップショット（プロジェクトのバックアップ）の保存・管理。
    - **中央パネル (`NovelEditor.tsx`):** 小説本文の表示・編集エリア。
    - **右パネル (`RightPanel.tsx`):** AIアシスタントとの対話エリア。
    - **モーダル群 (`ModalManager.tsx`):** 各種設定の編集や、相関図などの専用ツールを提供するオーバーレイウィンドウ。

### 各UI要素の機能と操作手順
（詳細なリストは`manual/07-ui-reference.md`に準拠するため、ここでは主要な要素のみ抜粋）

- **AIモード切替 (ラジオボタン):**
  - **目的:** AIの役割を「相談役」か「執筆者」かに切り替える。
  - **操作:** 右パネルの「相談モード」「執筆モード」を選択。
  - **内部処理:** `aiSlice`の`generationMode`状態を更新。この状態は`submitMessage`時にAPIへ渡され、AIのシステムプロンプトと挙動を変化させる。

- **ナレッジリンク (`[[項目名]]`):**
  - **目的:** 本文や設定項目から、関連するナレッジへ素早くアクセスする。
  - **操作:** 本文編集時に`[[...]]`でナレッジ名を囲む。表示されたリンクをクリックする。
  - **内部処理:** `utils.ts`の`parseMarkdown`関数がテキストをHTMLに変換する際、`[[...]]`構文を検出し、`data-knowledge-id`属性を持つ`<a>`タグに変換。`App.tsx`でイベントリスナーをセットアップし、クリック時に`openModal`アクションを発火させる。

### 利用者の典型的な導線（ユーザーフロー）
1.  **プロジェクト作成:** `プロジェクト選択画面`でタイトルを入力し、`標準モード`で作成。
2.  **初期設定:** `メイン画面`に遷移。左パネルの「キャラクター」`+`ボタンから`キャラクター設定モーダル`を開き、AIアシスタントを使って主人公を作成・保存。
3.  **プロット相談:** 右パネルを`相談モード`にし、「主人公が冒険に出るきっかけのアイデアを考えて」と入力。AIとアイデアを練る。
4.  **執筆:** 右パネルを`執筆モード`に切り替え、「物語の冒頭、主人公が故郷の村で過ごしているシーンを描写して」と指示。中央パネルに本文が生成される。
5.  **設定の追加と執筆の継続:** 物語に新しいキャラクターや地名が登場したら、都度左パネルから設定を追加。追加した設定をAIが参照し、一貫性を保ちながら物語の続きを執筆させる。
6.  **推敲と整理:** `アウトライン`タブで章構成を確認・整理。`タイムラインモーダル`で時系列の矛盾がないかチェック。
7.  **書き出し:** ヘッダーの`.htmlで出力`ボタンから、装飾を保持した形で作品をファイルに保存する。

#### 開発者向け備考
- 現在、モーダルウィンドウが多層的に開くことがあり、UIが複雑化する傾向にあります。特にキャラクター設定モーダル内でさらにAIアシスタントモーダルが開く構造は、状態管理を複雑にしています。将来的には、一部のモーダルをパネル内でのインライン編集やドック形式に置き換えることを検討すると、UXが向上する可能性があります。

#### 整合性スコア（自己評価）: 90/100
- ユーザーの操作フローとUIの主要な機能は網羅できていますが、すべてのUI要素のインタラクションを詳細に記述するにはドキュメントが長大になりすぎるため、主要なものに絞っています。

---

## 03. AIモジュールの仕様

**要約:** この章では、アプリケーションの核となるAIモジュール（Gemini APIとの連携部分）の動作原理、参照するデータの流れ、そして各種設定がAIの出力に与える影響について詳述します。

### 物語生成AIの動作（参照情報の流れ）
- **目的:** ユーザーの指示に基づき、プロジェクトの文脈に沿った物語の続きや相談応答を生成します。
- **内部処理 (`novelApi.ts`の`generateNovelContinuation`関数):**
  1. **コンテキスト構築:** AIへのリクエスト前に、プロジェクトデータから以下の情報を抽出し、Markdown形式の長大な文字列（コンテキスト）を構築します。
     - **キャラクター設定:** `formatSettings`で整形。
     - **相関図:** `formatRelations`で整形。
     - **ナレッジベース:** `formatKnowledge`で整形。ピン留めされた項目は「最優先ルール」としてマークされる。
     - **プロット要約:** `memoryScope`設定が`summary`または`full_context`の場合、プロットボードの「章のまとめ」を結合。
     - **小説本文:** `formatNovelContent`で整形。`memoryScope`設定に応じて、参照する本文の範囲（直近2ブロック、章全体、全文など）を決定。
  2. **システムプロンプト構築:** `generationMode`（執筆/相談）に応じて、AIの役割を定義するシステムプロンプトを構築します。これには、ペルソナ設定、出力形式（JSON）、各種フォーマットルール（セリフ、ナレッジリンクなど）が含まれます。
  3. **APIリクエスト:** 構築したコンテキストとユーザーのプロンプトを結合し、システムプロンプトと共にGemini API (`gemini-2.5-flash`) に送信します。`responseMimeType: 'application/json'`と`responseSchema`を指定し、確実なJSON出力を要求します。
  4. **レスポンス処理:** 返却されたJSONをパースし、`replyText`（AIの返答）、`newChunk`（生成された本文）、`suggestions`（提案）などを`aiSlice`に渡して状態を更新します。

### 相談モードと生成モードの違い
- **相談モード (`consult`):**
  - **目的:** 物語の内容には触れず、アイデア出しや構成の相談を行う。
  - **AIとの関係:** AIは「編集者」や「友人」といったペルソナになり、物語を*書かずに*物語に*ついて*話します。
  - **内部処理:** システムプロンプトが「あなたは執筆コンサルタントです」という内容に切り替わり、レスポンススキーマから`newChunk`（本文）が除外されます。
- **執筆モード (`write`):**
  - **目的:** 物語の続きを生成する。
  - **AIとの関係:** AIは「クリエイティブライター」として、指定されたスタイルで本文を生成します。
  - **内部処理:** システムプロンプトが「あなたは小説家です」という内容になり、レスポンススキーマに`newChunk`または`continuations`（複数提案）が含まれます。

### 各設定（文体・温度・参照範囲など）の影響
- **ペルソナ (`assistantPersona`):** AIの返答テキスト（`replyText`）の口調を決定します。システムプロンプト内で厳密に指示されます。
- **創造性 (`creativity`):** APIリクエスト時の`temperature`パラメータに変換されます（控えめ: 0.3, 普通: 0.7, 大胆: 1.0）。値が高いほど、AIはより予測不能で独創的な文章を生成しやすくなります。
- **記憶の範囲 (`memoryScope`):** `formatNovelContent`関数がAIに渡す本文の量を制御します。`full_context`は最も一貫性が高いですが、トークン数を多く消費し、コストと遅延が増加する可能性があります。
- **セリフのフォーマット (`showSpeakerInDialogue`, `applySpeakerColorToDialogue`):** システムプロンプト内のセリフ出力に関するルールを詳細に切り替えます。これにより、`アラン「こんにちは」`、`「こんにちは」とアランは言った`、`<speaker name="アラン">...</speaker>`といった多様な形式の出力を制御します。
- **文体模倣 (`writingStyleMimicry`):** ONの場合、システムプロンプトに「ユーザーの文体を分析し、模倣せよ」という強力な指示が追加されます。これにより、AIは独自のスタイルを抑制し、既存の本文の文長、語彙、リズムに合わせようとします。

### AIが参照するデータの優先順位
システムプロンプト内の記述に基づき、AIは以下の優先順位で情報を参照するように指示されています。

1.  **ピン留めされたナレッジ (`Pinned Knowledge`):** 最優先される「絶対的なルール」。
2.  **その他のナレッジ:** 物語世界の「不変のルール」。
3.  **キャラクター設定、相関図:** 登場人物に関する基本情報。
4.  **プロット要約:** 物語全体の流れ。
5.  **小説本文:** 直近の文脈と文体。
6.  **ユーザーの最新プロンプト:** 今回の生成で達成すべき具体的なタスク。

#### 開発者向け備考
- プロンプトインジェクション対策として、AIに渡すコンテキスト内のユーザー入力（設定項目など）は、適切にエスケープ処理を施すか、明確に「これはユーザー入力です」とAIに伝える区切り文字を入れることが推奨されます。
- 現在の`memoryScope`はチャンク数に基づいた単純なスライスですが、将来的にはテキストのベクトル化と類似度検索を用いて、現在のプロンプトに最も関連性の高い過去のシーンを自動的にコンテキストに含める、より高度なRAG（Retrieval-Augmented Generation）の実装が考えられます。

#### 整合性スコア（自己評価）: 95/100
- AIとの連携という最も複雑な部分について、プロンプトエンジニアリングの観点から内部的な指示内容まで踏み込んで解説できているため。

---

## 04. 設定データ管理

**要約:** この章では、物語の構成要素である各設定データが、アプリケーション内部でどのように構造化され、管理されているかを説明します。

### キャラクター設定の保存・呼び出し処理
- **目的:** `SettingItem`型（`type: 'character'`）のデータを管理します。
- **使用方法:** ユーザーは左パネルまたは各種モーダル経由でキャラクターを編集します。
- **AIとの関係:** `formatSettings`関数を通じて整形され、AIのコンテキストの一部となります。
- **内部処理:**
  - データは`Project.settings`配列内に`type: 'character'`として格納されます。
  - `dataSlice`の`handleSaveSetting`アクションが、新規作成（IDなし）または更新（IDあり）を判断し、`settings`配列を更新します。
  - 呼び出しは、`useStore`を通じて`Project.settings`からフィルタリングして行われます。

### 世界観設定とナレッジベース
- **世界観設定:**
  - **目的:** `SettingItem`型（`type: 'world'`）のデータを管理します。
  - **内部処理:** キャラクター設定と同様に`Project.settings`配列内に`type: 'world'`として格納されます。`handleSaveSetting`で管理されます。
- **ナレッジベース:**
  - **目的:** `KnowledgeItem`型のデータを管理します。これは物語世界の「不変のルール」です。
  - **内部処理:** データは`Project.knowledgeBase`配列に格納されます。`handleSaveSetting`が`type: 'knowledge'`を識別して処理します。`isPinned`プロパティは`handleToggleKnowledgePin`で切り替えられ、`formatKnowledge`関数によってAIコンテキスト内での優先順位が決定されます。

### プロットボード、タイムライン、関係図の構造
- **プロットボード:**
  - **目的:** 物語の構成を管理します。
  - **内部処理:** `Project`オブジェクト内の以下の配列・オブジェクトで管理されます。
    - `plotBoard`: `PlotItem`の配列（カード情報）。
    - `plotRelations`: `PlotRelation`の配列（カード間の線情報）。
    - `plotNodePositions`: カードの座標情報。
    - `plotTypeColors`: カード種別ごとの色情報。
  - `PlotBoardModal`コンポーネント内で状態が管理され、保存時に`handleSavePlotBoard`アクションがこれら全てを一度に更新します。
- **タイムライン:**
  - **目的:** 物語内の出来事を時系列で管理します。
  - **内部処理:**
    - `timeline`: `TimelineEvent`の配列（出来事）。
    - `timelineLanes`: `TimelineLane`の配列（列情報）。
  - `TimelineModal`内で状態が管理され、`handleSaveTimeline`で更新されます。
- **関係図（相関図）:**
  - **目的:** キャラクター間の関係性を管理します。
  - **内部処理:**
    - `characterRelations`: `Relation`の配列（キャラクター間の線情報）。
    - `nodePositions`: キャラクターノードの座標情報。
  - `CharacterChartModal`内で状態が管理され、`handleSaveChart`で更新されます。

### 設定の一貫性チェックロジック（仮）
- **目的:** 削除された設定項目への参照が残らないようにし、データの整合性を保ちます。
- **内部処理（現状）:**
  - 厳密な自動チェックロジックは実装されていません。
  - `handleDeleteSetting`内で、キャラクターが削除された際に、関連する`characterRelations`と`nodePositions`をフィルタリングする処理が存在します。これが現状の主要な一貫性維持機能です。
- **注意点:**
  - 例えば、キャラクターを削除しても、タイムラインのイベント説明文にそのキャラクター名が残っている、といったケースは検出できません。
  - `parseMarkdown`内のナレッジリンク処理では、存在しない項目へのリンクは単なるテキストとして表示されるため、エラーにはなりませんが、「リンク切れ」を明示的に警告する機能はありません。

#### 開発者向け備考
- 将来的な拡張として、設定項目（キャラクター、世界観など）を削除する際に、プロジェクト全体（本文、タイムライン、他の設定項目）をスキャンし、削除対象の名前が含まれている箇所をリストアップしてユーザーに警告する機能を実装することが望ましいです。これにより、意図しない設定の不整合を防ぐことができます。

#### 整合性スコア（自己評価）: 85/100
- 各データの保存フローは正確ですが、一貫性チェックロジックが限定的であるため、その点を反映してスコアを調整しました。

---

## 05. 執筆・生成フロー

**要約:** この章では、ユーザーがAIに指示を出してから、その結果が画面に反映されるまでの具体的な処理フローを解説します。

### 実際のAI出力手順（ユーザー操作→AI応答まで）
1.  **ユーザー操作:** ユーザーが右パネルのテキストエリアにプロンプトを入力し、「送信」ボタン（または`Ctrl+Enter`）を押します。
2.  **アクション発火:** `aiSlice`の`submitMessage`アクションがトリガーされます。
3.  **状態更新（リクエスト前）:**
    - `isLoading`が`true`に設定され、UIがローディング状態に移行します。
    - ユーザーのプロンプトが`ChatMessage`として`chatHistory`に追加されます。
4.  **API呼び出し:** `novelApi.ts`の`generateNovelContinuation`関数が、現在のプロジェクトデータとユーザーのプロンプトを引数として呼び出されます。
5.  **コンテキスト構築:** `generateNovelContinuation`内部で、`formatSettings`, `formatKnowledge`などのユーティリティ関数を使い、AIに渡すための長大なコンテキスト文字列と、モードに応じたシステムプロンプトが構築されます。
6.  **Gemini APIリクエスト:** `withTimeout`でラップされた`ai.models.generateContent`が実行され、APIにリクエストが送信されます。レスポンスはJSON形式が指定されています。
7.  **レスポンス受信と解析:** APIからJSON文字列が返却され、`JSON.parse`でオブジェクトに変換されます。
8.  **状態更新（リクエスト後）:**
    - `isLoading`が`false`に戻ります。
    - AIの応答（`replyText`）が`ChatMessage`として`chatHistory`に追加されます。
    - **執筆モードの場合:**
      - `newChunk`（本文）が`novelContent`配列の末尾に追加されます。
      - `highlightedChunkId`が新しいチャンクのIDに設定され、画面上でハイライト表示されます。
    - AIからの提案（`suggestions`）があれば、`aiSuggestions`状態に格納され、UIに表示されます。
9.  **UI再レンダリング:** `chatHistory`と`novelContent`の変更がReactコンポーネントに反映され、画面が更新されます。

### 複数提案モードの挙動
- **目的:** ユーザーに物語の分岐を提示し、選択の自由度を高めます。
- **使用方法:** AI設定または右パネルのトグルで`generateMultipleContinuations`を`true`にします。
- **内部処理:**
  - `generateNovelContinuation`内のシステムプロンプトが変化し、AIに対して複数の展開案（`continuations`配列）を生成するように指示します。
  - APIからのレスポンスには`newChunk`の代わりに`continuations`配列が含まれます。
  - `aiSlice`は、この配列を`continuationChoices`状態に格納します。
  - UI（`RightPanel`）は`continuationChoices`を検知し、ユーザーに選択肢を提示します。
  - ユーザーが「この展開を採用」ボタンを押すと、`handleAdoptContinuation`アクションが発火し、選択されたテキストが新しい`NovelChunk`として`novelContent`に追加されます。同時に`continuationChoices`は`null`にリセットされます。

### 一貫性維持のためのAI内処理（仮想的に説明）
- **目的:** AIが物語の文脈や設定を忘れずに、一貫した内容を生成するように制御します。
- **内部処理:** これは主にプロンプトエンジニアリングによって実現されています。
  1.  **階層的な情報提示:** AIに渡すコンテキストは、「最優先ルール（ピン留めされたナレッジ）」→「不変のルール（ナレッジ）」→「キャラクター設定」→「物語の要約」→「直近の本文」というように、重要度の高い情報から順に構造化されています。
  2.  **明確な指示:** システムプロンプト内で、「あなたはこれらのルールを絶対に守らなければならない」と厳密に指示しています。
  3.  **役割の定義:** 「あなたは小説家です」「あなたは編集者です」と役割を明確にすることで、AIの振る舞いを制御し、意図しない本文生成（相談モード時など）を防ぎます。
  4.  **出力形式の強制:** `responseMimeType: 'application/json'`と`responseSchema`を指定することで、AIは自由な散文ではなく、規定されたJSON構造で応答せざるを得なくなり、出力の安定性が向上します。

#### 開発者向け備考
- `submitMessage`はアプリケーション内で最も複雑なアクションの一つです。状態の更新、API呼び出し、エラーハンドリングが密結合しているため、将来的なリファクタリングの対象となり得ます。例えば、API通信ロジックをより独立させ、状態更新はレスポンスを受け取った後に行う、といった分離が考えられます。

#### 整合性スコア（自己評価）: 95/100
- ユーザー操作からUI更新までの一連の流れを、内部的な状態変化も含めて詳細に追跡できているため。

---

## 06. 出力と保存

**要約:** この章では、ユーザーが作成した物語を外部ファイルとして保存する機能の内部処理について説明します。

### HTML出力、TXT出力の処理フロー
- **目的:** ユーザーが作品を共有・閲覧しやすい形式で保存できるようにします。
- **使用方法:** ヘッダーの「.txtで出力」「.htmlで出力」ボタン、または左パネルのドロップダウンメニューから選択します。
- **内部処理:**
  - **TXT出力 (`handleExportTxt` in `App.tsx`):**
    1. `Project.novelContent`配列から全ての`text`プロパティを抽出し、`\n\n`で連結して単一の文字列を作成します。
    2. 作成した文字列から`Blob`オブジェクトを`type: 'text/plain'`で生成します。
    3. `URL.createObjectURL`でBlobへのURLを生成し、ダウンロード用の`<a>`タグを作成してクリックイベントを発生させ、ダウンロードをトリガーします。
  - **HTML出力 (`exportHtml` in `dataSlice.ts`):**
    1. `HtmlExportModal`でユーザーが選択したオプション（表紙、目次、登場人物一覧など）を受け取ります。
    2. プロジェクトデータ（本文、キャラクター設定など）とオプションを基に、完全なHTML文字列を動的に構築します。
    3. 本文の各チャンクは`parseMarkdown`関数を通してHTMLに変換され、ルビや文字色などの装飾が再現されます。
    4. 表示設定（テーマ、フォント）に応じたCSSも`<style>`タグ内に埋め込まれます。
    5. TXT出力と同様に、生成されたHTML文字列からBlobを作成し、ダウンロードをトリガーします。

### JSONエクスポートの構造
- **目的:** プロジェクト全体のバックアップ、または別の環境（他のブラウザやPC）への移行を可能にします。
- **使用方法:** 左パネルの「保存 & 書き出し」ドロップダウンから「プロジェクト(.json)」を選択します。
- **内部処理 (`handleExportProject` in `App.tsx`):**
  1. `useStore`から現在アクティブなプロジェクトの完全な`Project`オブジェクトを取得します。
  2. `JSON.stringify(projectData, null, 2)`を使用して、整形されたJSON文字列に変換します。
  3. Blobを作成し、`.json`ファイルとしてダウンロードをトリガーします。
- **構造:** ダウンロードされるJSONファイルは、`types.ts`で定義されている`Project`型の構造と完全に一致します。これには、本文、すべての設定、チャット履歴、AI設定、表示設定などが含まれます。

### プレビューとフォーマット設定
- **プレビューモーダル (`PreviewModal.tsx`):**
  - **目的:** 編集UIなしで、作品全体の見た目を確認する機能を提供します。
  - **内部処理:** `novelContent`配列を`map`処理し、各`NovelChunk`を`parseMarkdown`関数でHTMLに変換して表示します。総文字数もここで計算されます。
- **表示設定 (`DisplaySettingsPopover.tsx`):**
  - **目的:** ユーザーが執筆環境の見た目をカスタマイズできるようにします。
  - **内部処理:** ユーザーがテーマ、フォント、文字サイズを変更すると、`handleDisplaySettingChange`アクションが発火し、`Project.displaySettings`オブジェクトが更新されます。`NovelEditor`コンポーネントは、この`displaySettings`を購読しており、変更があると即座にスタイルが再適用されます。この設定はプロジェクトごとに永続化されます。

#### 開発者向け備考
- HTML書き出し機能は、CSSを直接HTML内に埋め込むシンプルな形式です。将来的に、より高度な書き出しオプション（例: EPUB形式、PDF形式、縦書きレイアウトの維持）をサポートする場合、外部ライブラリ（`html-to-pdf`, `epub-gen`など）の導入が必要になります。

#### 整合性スコア（自己評価）: 90/100
- 各出力機能のフローは正確に記述されていますが、HTML生成のテンプレート文字列の具体的な構造については省略しているため。

---

## 07. テストとデバッグ

**要約:** この章では、アプリケーションの品質を保証するためのテストケース、デバッグ手順、および想定されるエラーについて概説します。

### 主要テストケース一覧
アプリケーションのコア機能が正しく動作することを確認するため、以下のテストシナリオが定義されています。（詳細は`manual/08-test-cases.md`および`manual/09-user-acceptance-test.md`を参照）

- **プロジェクト管理:** 新規作成、インポート、削除、シンプル/標準モードの切り替え。
- **キャラクター設定:** AIアシスタント（`create`/`update`モード）を使用した設定の生成・更新、立ち絵生成、手動編集。
- **執筆フロー:** 相談モードでのアイデア出し、執筆モードでの本文生成、複数提案機能、Undo/Redo。
- **設定ツール:** 相関図、タイムライン、プロットボード、ナレッジベースのCRUD（作成、読み取り、更新、削除）操作とデータ連携。
- **本文編集:** Markdown装飾（ルビ、太字など）、ナレッジリンクの動作。
- **出力:** TXT, HTML, JSON形式でのエクスポートと、プレビュー表示の正確性。
- **ストレステスト:** 巨大なテキストの貼り付け、特殊文字の使用、APIボタンの連打。

### 自動検出できる不具合（仮）
現在、自動テストフレームワークは導入されていませんが、将来的に導入する場合、以下の項目を自動化することが可能です。

- **参照抜け:** キャラクター削除後に相関図にそのキャラクターIDが残っていないか。
- **設定衝突:** 同じ名前のキャラクターやナレッジ項目が重複して作成されていないか。
- **データ型不整合:** `validateAndSanitizeProjectData`をテストケースに組み込み、不正な形式のプロジェクトデータをインポートしようとした際に、適切にサニタイズされるか、またはエラーをスローするかを確認。
- **UIコンポーネントのレンダリング:** 各モーダルが開閉できるか、主要なボタンが存在するかといった基本的なUIテスト。

### テスト実施時の手順
1.  **データリセット:** `manual/08-test-cases.md`の指示に従い、ブラウザのローカルストレージをクリアして、新規ユーザーの状態から開始します。
2.  **総合テストシナリオの実施:** `manual/09-user-acceptance-test.md`に従い、一人のユーザーとして短編小説を一本書き上げるフローをシミュレートします。これにより、機能間の連携や全体的なUXを確認します。
3.  **個別テストケースの実施:** 特定の機能を修正した場合、`manual/08-test-cases.md`から関連する項目をピックアップして実施し、リグレッション（修正による新たな不具合）が発生していないかを確認します。

### 想定されるエラーと原因の推定
- **「AIの応答がタイムアウトしました」:**
  - **原因:** ユーザーのネットワーク接続が不安定、またはGemini APIのサーバー負荷が高い。AIが非常に長い文章を生成しようとしている場合にも発生しやすい。
  - **対処:** `apiUtils.ts`の`withTimeout`関数がエラーをスローし、`aiSlice`がエラーメッセージをチャットに表示する。
- **「APIキーが無効です」「Quota exceeded」:**
  - **原因:** `process.env.API_KEY`に設定されたAPIキーが正しくない、またはGoogle AI Studioの無料利用枠の上限に達した。
  - **対処:** `handleError`関数がエラーメッセージを解釈し、ユーザーに分かりやすいメッセージを生成する。
- **モーダルやUIが正常に表示されない、操作不能になる:**
  - **原因:** Reactの状態管理（Zustand）で不整合が発生しているか、レンダリング中にJavaScriptエラーが発生している可能性が高い。
  - **対処:** ブラウザの開発者ツールでコンソールログを確認し、エラーの原因を特定する。
- **インポートしたプロジェクトが開けない、またはデータが欠損している:**
  - **原因:** インポートされたJSONファイルが破損している、または古いバージョンのデータ構造である。
  - **対処:** `validateAndSanitizeProjectData`関数が、古いデータ構造を新しい構造に変換しきれていない可能性がある。この関数のロジックを見直す必要がある。

#### 開発者向け備考
- デバッグを効率化するため、開発ビルドではZustandの`redux-devtools`ミドルウェアを導入することを強く推奨します。これにより、アクションの発火とそれに伴う状態変化を時系列で追跡でき、不整合の原因特定が容易になります。

#### 整合性スコア（自己評価）: 90/100
- テストとデバッグに関する手動プロセスは網羅されていますが、自動化に関する記述はまだ構想段階であるため。

---

## 08. 改善提案と拡張計画

**要約:** この章では、アプリケーションの現状の課題を整理し、将来的な機能拡張や品質向上のための具体的な提案を記述します。

### 現状の課題
これまでの監査と分析を通じて、以下の課題が特定されています。

- **AIの長期記憶の問題:**
  - **現象:** `memoryScope`設定に依存しているが、特に長い物語の場合、序盤の伏線やキャラクターの微細な変化を忘れることがある。
  - **原因:** コンテキストウィンドウの物理的な制限。APIに渡せる情報量には限りがあるため、古い情報はコンテキストから除外されてしまう。
- **Undo/Redo機能のパフォーマンス懸念:**
  - **現象:** プロジェクトデータが大きくなるにつれて、Undo/Redoの履歴を保存する際のメモリ消費量が増大し、パフォーマンスが低下する可能性がある。
  - **原因:** 操作ごとにプロジェクト全体のスナップショットを保存する現在の実装。
- **UIの複雑性:**
  - **現象:** モーダル内でさらにモーダルが開くなど、UIの階層が深くなる箇所があり、ユーザーが現在位置を見失いやすい。
  - **原因:** 各機能を独立したモーダルとして実装しているため。
- **クライアントサイド依存:**
  - **現象:** データがブラウザ内にしか保存されないため、デバイス間の同期や共同編集ができない。`localStorage`の容量制限のリスクもある。
  - **原因:** バックエンドサーバーを持たない純粋なクライアントサイドアプリケーションであるため。

### UX向上・内部最適化の提案
- **AIアシスタントの統合:**
  - **提案:** キャラクター用、世界観用など、個別のAIアシスタントモーダルを廃止し、右パネルのメインAIアシスタントに機能を統合する。「キャラクター『ルナ』について相談」のように、アシスタントが文脈から対象を判断する形式を目指す。
  - **効果:** UIの階層を浅くし、操作を右パネルに集約することで、よりシームレスな体験を提供。
- **差分Undo/Redoの実装:**
  - **提案:** `immer`や`jsondiffpatch`のようなライブラリを導入し、操作前後の状態の差分（パッチ）のみを履歴として保存する方式に変更する。
  - **効果:** メモリ消費量を大幅に削減し、大規模プロジェクトでも軽快な動作を維持。
- **RAG (Retrieval-Augmented Generation) の導入:**
  - **提案:** プロジェクトの本文や設定項目をチャンクに分割し、ベクトル化して保存する。AIへのリクエスト時に、ユーザーのプロンプトと関連性の高いベクトルを検索し、それらを優先的にコンテキストに含める。
  - **効果:** AIの長期記憶問題を大幅に改善し、物理的なコンテキスト長の制限を受けにくくなる。

### 今後の発展構想
- **自動整合性チェックAI:**
  - **構想:** 定期的にプロジェクト全体をスキャンし、「タイムラインで死亡したはずのキャラクターが後のシーンで会話している」「ナレッジに反する記述がある」といった矛盾点を自動で検出・警告する専用のAIエージェントを開発する。
- **バックエンドの導入とクラウド同期:**
  - **構想:** FirebaseやSupabaseのようなBaaS (Backend as a Service) を導入し、プロジェクトデータをクラウド上に保存する。
  - **効果:**
    - デバイス間でのデータ同期。
    - リアルタイム共同編集機能の実装基盤。
    - `localStorage`の容量制限からの解放。
- **プラグイン・エコシステムの構築:**
  - **構想:** サードパーティ開発者が独自の機能（例: 特定のジャンルに特化した名前ジェネレーター、高度な文法校正ツール）を開発し、追加できるプラグイン機構を設ける。
- **マルチモーダル入力:**
  - **構想:** ユーザーがラフスケッチをアップロードすると、AIがその内容を解釈してキャラクター設定の草案を作成したり、ユーザーが声で物語の続きを口述すると、AIがそれを文章化したりする機能。

#### 開発者向け備考
- これらの拡張計画は、いずれも現状のアーキテクチャからの大きな変更を伴います。特にバックエンド導入は影響が大きいため、段階的な移行計画（まずは認証とデータ同期から、次にリアルタイム機能、など）を慎重に設計する必要があります。

#### 整合性スコア（自己評価）: 95/100
- 現状の課題とそれに対する具体的な技術的解決策、そして将来的なビジョンをバランス良く提示できているため。
